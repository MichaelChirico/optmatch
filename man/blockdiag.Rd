% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/InfinitySparseMatrix.R
\name{blockdiag}
\alias{blockdiag}
\title{Stitch together subgroup-specific distances}
\usage{
blockdiag(..., force_unique_names = FALSE)
}
\arguments{
\item{...}{Any number of elements of class \code{matrix},
\code{DenseMatrix}, \code{InfinitySparseMatrix}, or
\code{BlockedInfinitySparseMatrix}}

\item{force_unique_names}{Default \code{FALSE}. When row or column names are
not unique amongst all distances, if \code{FALSE}, throw a warning and
rename all rows and columns to ensure unique names. If \code{TRUE}, error
on non-unique names.}
}
\value{
A \code{BlockedInfinitySparseMatrix}
}
\description{
This function generates a single blocked distance matrix given several
distance matrixes defined on subgroups.
}
\details{
When you've generated several distances matrices on subgroups in your
analysis, you may wish to combine them into a single distance matrix. The
\code{blockdiag} function facilitates this.

Any \code{BlockedInfinitySparseMatrix} include in \code{...} will be broken
into individual \code{InfinitySparseMatrix} before being joined back
toegther. For example, if \code{b} is a \code{BlockedInfinitySparseMatrix}
with 2 subgroups and \code{m} is a distance without subgroups, then
\code{blockdiag(b, m)} will be a \code{BlockedInfinitySparseMatrix} with 3
subgroups.

If there are any shared names (either row or column) amongst all distances
passed in, by default all matrixes will be renamed to ensure unique names by
appending "X." to each distance, where "X" is ascending lower case letters
("a.", "b.", etc). Setting the \code{force_unique_names} argument to
\code{TRUE} errors on this instead.

Note that you do \strong{not} have to combine subgroup distances into a
single blocked distance using this function to ultimately obtain a single
matching set. Instead, take a look at the vignette
\code{vignette("matching-within-subgroups", package = "optmatch")} for
details on combining multiple matches.
}
\examples{
data(nuclearplants)
m1 <- match_on(pr ~ cost, data = subset(nuclearplants, pt == 0),
               caliper = 1)
m2 <- match_on(pr ~ cost, data = subset(nuclearplants, pt == 1),
               caliper = 1.3)
blocked <- blockdiag(m1, m2)
}
