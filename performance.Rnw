\documentclass[12pt]{article}

\title{\texttt{optmatch} Performance Testing}

\begin{document}
\maketitle

<<echo = F>>=
library(optmatch)
@

The goal of this document is provide some basic performance testing of the
\texttt{optmatch} package. In most matching workflows, a user first creates
distances, produces one or more matches, assesses balance on a given match,
and, provided balance meets necessary requirements, proceeds to analysis. Of
these tasks, \texttt{optmach} is responsible for distance creation and
creating the match. These two tasks will be considered separately. The
remainder of this document lays out the performance testing strategy and then
implements it for the distance creation and matching routines in
\texttt{optmatch}.

\section{Performance Testing Strategy}

\texttt{R} provides built in execution profiling through the \texttt{Rprof}
function (and a similarly named command line option). When invoked, this
function regularly interrupts normal processing and writes out the current
call stack to a file. This information can be used to attribute the portion of
run time attributable different functions.

<<echo = F>>=
library(profr)
@

For interpretation of this data, we rely on the \texttt{profr} package, which
provides some graphical summaries to help make raw profile data more manageable.

Since we suspect that creation of large data sets may account for a sizeable
portion of the runtime of large problems, we also profile memory usage
with\ldots.

\subsection{Simulated Data}

Before proceeding to the actual profiling, we begin by creating some simulated
data.

<<create-data>>=
set.seed(20130125) # so that the random values we generate will be consistent
N <- 1000
X <- data.frame(X1 = rnorm(N), 
                X2 = rnorm(N, mean = runif(N, -5, 5)), 
                X3 = as.factor(sample(letters[1:5], N, replace = T)))

mm <- model.matrix(I(rep(1, N)) ~  X1 + X2 + X1:X3, data = X)
coefs <- runif(dim(mm)[2], -2, 2)
logits <- as.vector(coefs %*% t(mm)) 
DATA <- data.frame(Z = rbinom(N, size = 1, prob = plogis(logits)), X)
model <- glm(Z ~ X1 + X2 + X1:X3, data = DATA)
predicted <- predict(model)

# clear out memory and run the garbage collector before proceeding
rm(mm)
rm(logits)
rm(X)
gc()
ls()
@

\section{Distance Creation}

We begin by benchmarking distance creation. The \texttt{match\_on.numeric}
method has the least complicated interface and applies the least
pre-processing to the input. In subsequent sections, we test to the other
methods to see what overhead they add.

\subsection{Dense Problem Distance Creation}

<<>>=
gc()

benchmark.dense <- profr(result.dense <- match_on(x = predicted, z = DATA$Z))
@

\begin{figure}
\centering
<<fig = T>>=
plot(benchmark.dense)
@
\caption{Profiling diagram for dense distance creation for $N = 
\Sexpr{N}$ units.}
\label{fig:dense}
\end{figure}

\subsection{Sparse Problem Distance Creation}

There are two ways to create sparse problems. In the first, we use the
\texttt{caliper} argument (for the \texttt{numeric} and \texttt{glm} methods
of \texttt{match\_on}). This argument looks over all the treated and control
values and computes which treated and control units should be compared, and
then computes the exact distances between them. The \texttt{within} argument
is more general, applying to all \texttt{match\_on} methods, but can sometimes
require generating a dense matrix first (though not always --- the
\texttt{exactMatch} function doesn't require a dense matrix). 

\subsubsection{Caliper argument}

<<>>=
gc()
benchmark.sparse.caliper <- profr(result.sparse.caliper <- match_on(x =
predicted, z = DATA$Z, caliper = 1))
@

This matrix has 
\Sexpr{round(100 * length(result.sparse.caliper) / (N*N), 1)}\% finite
entries.

\begin{figure}
\centering
<<fig = T>>=
plot(benchmark.sparse.caliper)
@
\caption{Profiling diagram for caliper based sparse distance creation for $N = 
\Sexpr{N}$ units.}
\label{fig:sparse-caliper}
\end{figure}

\subsubsection{Within argument}

\subsection{\texttt{match\_on} Methods}
\subsubsection{\texttt{formula}}
\subsubsection{\texttt{glm}}

\section{Matching}
\subsection{Dense problems}
\subsection{Dense, stratified problems}
\subsection{Sparse problems}
\subsection{Sparse, stratified problems}
\subsection{\texttt{pairmatch}}
\subsection{User supplied constraints}

\appendix

\section{Environment}

<<>>=
sessionInfo()
@

\section{Saving Results}
<<>>=
save(file = "performance.rda",
  N,
  DATA,
  model,
  predicted,
  result.dense,
  benchmark.dense,
  result.sparse.caliper,
  benchmark.sparse.caliper)
@
\end{document}
