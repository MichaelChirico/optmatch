\documentclass[12pt]{article}

\title{\texttt{optmatch} Performance Testing}

\begin{document}
\maketitle

<<echo = F>>=
library(optmatch)
@

The goal of this document is provide some basic performance testing of the
\texttt{optmatch} package. In most matching workflows, a user first creates
distances, produces one or more matches, assesses balance on a given match,
and, provided balance meets necessary requirements, proceeds to analysis. Of
these tasks, \texttt{optmach} is responsible for distance creation and
creating the match. These two tasks will be considered separately. The
remainder of this document lays out the performance testing strategy and then
implements it for the distance creation and matching routines in
\texttt{optmatch}.

\section{Performance Testing Strategy}

\texttt{R} provides built in execution profiling through the \texttt{Rprof}
function (and a similarly named command line option). When invoked, this
function regularly interrupts normal processing and writes out the current
call stack to a file. This information can be used to attribute the portion of
run time attributable different functions.

<<echo = F>>=
library(profr)
@

For interpretation of this data, we rely on the \texttt{profr} package, which
provides some graphical summaries to help make raw profile data more manageable.

Since we suspect that creation of large data sets may account for a sizeable
portion of the runtime of large problems, we also profile memory usage
with\ldots.

\subsection{Simulated Data}

Before proceeding to the actual profiling, we begin by creating some simulated
data.

<<create-data>>=
set.seed(20130125) # so that the random values we generate will be consistent
N <- 1000
X <- data.frame(X1 = rnorm(N), 
                X2 = rnorm(N, mean = runif(N, -5, 5)), 
                X3 = as.factor(sample(letters[1:5], N, replace = T)))

mm <- model.matrix(I(rep(1, N)) ~  X1 + X2 + X1:X3, data = X)
coefs <- runif(dim(mm)[2], -2, 2)
logits <- as.vector(coefs %*% t(mm)) 
DATA <- data.frame(Z = rbinom(N, size = 1, prob = plogis(logits)), X)
model <- glm(Z ~ X1 + X2 + X1:X3, data = DATA)
predicted <- predict(model)

# clear out memory and run the garbage collector before proceeding
rm(mm)
rm(logits)
rm(X)
gc()
ls()
@

\section{Distance Creation}

We begin by benchmarking distance creation. The \texttt{match\_on.numeric}
method has the least complicated interface and applies the least
pre-processing to the input. In subsequent sections, we test to the other
methods to see what overhead they add.

\subsection{Dense Problem Distance Creation}

<<>>=
gc()

benchmark.dense <- profr(result.dense <- match_on(x = predicted, z = DATA$Z))
@

\begin{figure}
\centering
<<fig = T>>=
plot(benchmark.dense)
@
\caption{Profiling diagram for dense distance creation for $N = 
\Sexpr{N}$ units.}
\label{fig:dense}
\end{figure}

\subsection{Sparse Problem Distance Creation}

There are two ways to create sparse problems. In the first, we use the
\texttt{caliper} argument (for the \texttt{numeric} and \texttt{glm} methods
of \texttt{match\_on}). This argument looks over all the treated and control
values and computes which treated and control units should be compared, and
then computes the exact distances between them. The \texttt{within} argument
is more general, applying to all \texttt{match\_on} methods, but can sometimes
require generating a dense matrix first (though not always --- the
\texttt{exactMatch} function doesn't require a dense matrix). 

\subsubsection{Caliper argument}

<<>>=
gc()
benchmark.sparse.caliper <- profr(result.sparse.caliper <- match_on(x =
predicted, z = DATA$Z, caliper = 1))
@

This matrix has 
\Sexpr{round(100 * length(result.sparse.caliper) / (N*N), 1)}\% finite
entries.

\begin{figure}
\centering
<<fig = T>>=
plot(benchmark.sparse.caliper)
@
\caption{Profiling diagram for caliper based sparse distance creation for $N = 
\Sexpr{N}$ units.}
\label{fig:sparse-caliper}
\end{figure}

\subsubsection{Within argument}


<<>>=
gc()
benchmark.sparse.within <- profr(result.sparse.within <- match_on(x =
predicted, z = DATA$Z, within = exactMatch(Z ~ I(X3 == "a" | X3 == "b"), data = DATA)))
@

This matrix has 
\Sexpr{round(100 * length(result.sparse.within) / (N*N), 1)}\% finite
entries.

\begin{figure}
\centering
<<fig = T>>=
plot(benchmark.sparse.within)
@
\caption{Profiling diagram for within based sparse distance creation for $N = 
\Sexpr{N}$ units.}
\label{fig:sparse-within}
\end{figure}


\subsection{\texttt{match\_on} Methods}

These additional methods add some pre-processing to the distance creation.
Both can work on sparse problems, but to keep things simple, these examples
just create dense matrices.

\subsubsection{\texttt{formula}}

<<>>=
gc()
benchmark.formula <- profr(result.formula <- match_on(x =
  Z ~ X1 + X2 + X3, data = DATA))
@

\begin{figure}
\centering
<<fig = T>>=
plot(benchmark.formula)
@
\caption{Profiling diagram for formula (Mahalanobis) distance creation for $N = 
\Sexpr{N}$ units.}
\label{fig:sparse-formula}
\end{figure}

\subsubsection{\texttt{glm}}

<<>>=
gc()
benchmark.glm <- profr(result.glm <- match_on(x =
  glm(Z ~ X1 + X2 + X3, data = DATA)))
@

\begin{figure}
\centering
<<fig = T>>=
plot(benchmark.glm)
@
\caption{Profiling diagram for \texttt{glm} distance creation for $N = 
\Sexpr{N}$ units.}
\label{fig:sparse-formula}
\end{figure}

\section{Matching}
Now that distance creation code has been benchmarked, we now consider the
matching process itself. We reuse the earlier distance objects. To keep things
simple, most of these matches will be computed using \texttt{fullmatch} at
default settings.

\subsection{Dense problems}

<<>>=
gc()

benchmark.matching.dense <- profr(result.matching.dense <-
  fullmatch(result.dense))
@

\begin{figure}
\centering
<<fig = T>>=
plot(benchmark.matching.dense)
@
\caption{Profiling diagram for dense matrix based matching for $N = 
\Sexpr{N}$ units.}
\label{fig:match-dense}
\end{figure}


% \subsection{Dense, stratified problems}

\subsection{Sparse problems}

For the first sparse matrix test, we use the result of the \texttt{caliper}
argument test. This kind of sparse problem must be passed to the solver as a
single unit.

<<>>=
gc()

benchmark.matching.sparse <- profr(result.matching.sparse <-
  fullmatch(result.sparse.caliper))
@

\begin{figure}
\centering
<<fig = T>>=
plot(benchmark.matching.sparse)
@
\caption{Profiling diagram for sparse matrix based matching for $N = 
\Sexpr{N}$ units.}
\label{fig:match-sparse}
\end{figure}


\subsection{Sparse, stratified problems}

This time we use a problem that has been stratified by a factor.
<<>>=
gc()

benchmark.matching.sparse.strat <- profr(result.matching.sparse.strat <-
  fullmatch(result.sparse.within))
@

\begin{figure}
\centering
<<fig = T>>=
plot(benchmark.matching.sparse.strat)
@
\caption{Profiling diagram for stratified sparse matrix based matching for $N = 
\Sexpr{N}$ units.}
\label{fig:match-sparse-strat}
\end{figure}


\subsection{\texttt{pairmatch}}

To change things up a little, we use pairmatch for this profile. Again, we use
the dense problem in order to focus on the matching aspect.

<<>>=
gc()

benchmark.matching.pairmatch <- profr(result.matching.pairmatch <-
  fullmatch(result.dense))
@

\begin{figure}
\centering
<<fig = T>>=
plot(benchmark.matching.pairmatch)
@
\caption{Profiling diagram for dense matrix pairmatching for $N = 
\Sexpr{N}$ units.}
\label{fig:match-pairmatch}
\end{figure}

\appendix

\section{Environment}

<<>>=
sessionInfo()
@

\section{Saving Results}
<<>>=
save(file = "performance.rda",
  N,
  DATA,
  model,
  predicted,
  # distances
  result.dense,
  benchmark.dense,
  result.sparse.caliper,
  benchmark.sparse.caliper,
  result.sparse.within,
  benchmark.sparse.within,
  result.formula,
  benchmark.formula,
  result.glm,
  benchmark.glm,
  # matching
  benchmark.matching.dense,
  result.matching.dense,
  benchmark.matching.sparse,
  result.matching.sparse,
  benchmark.matching.sparse.strat,
  result.matching.sparse.strat,
  benchmark.matching.pairmatch,
  result.matching.pairmatch)
@
\end{document}
