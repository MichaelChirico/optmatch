---
title: "Matching with Optmatch"
author: "Josh Errickson"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Matching with Optmatch}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

The `optmatch` package enables the user to perform several variations of
matching, from simple pair matching to a complete fullmatch.

The data set used in this vignette is `nuclearplants`, accesible by running

```{r,results="hide"}
library(optmatch)
data(nuclearplants)
```

Variables of note include `cost`, the cost of construction (in millions of
dollars) of the plant, and `pr`, an indicator for the prior existence of a plant
at the site. A potential research question of interest could be to see whether
the cost of a new plant is affected by the existence of a prior plant, which
could either decrease costs (since existing infrastructure may exist, and the
land is already ready for such construction) or increase costs (removing the
existing infrastructure may be costly). A concern may be lack of balance amongst
covariates between the two groups of interest.

To formalize notation, it is useful to think of the two groups as "control" and
"treatment". Therefore, consider the group which has a prior plant at the site
(`pr==1`) as the treatment group and the group which has no prior plant
(`pr==0`) as the control group.

# Propensity Score model

Matching is often done on propensity scores, especially in settings where there
are multiple covariates to balance upon. A propensity score of an observation is
the observations likelihood to have been in the treatment group given their
covariates. This is fit using a logistic regression model with the variable
indicating treatment assignment as the response (in the nuclear plants data,
`pr`) and all covariates we wish to balance on as predictors.

For the nuclear plants data, we could fit this model as

```{r}
psmod <- glm(pr ~ t1 + t2 + cap, family=binomial, data=nuclearplants)
```

The argument is that despite two observations perhaps having different
covariates, if they have similar propensity scores, then we can consider the
choice of which observation receives treatment is a mini-experiment.

We can look at the propensity scores by

```{r}
fitted(psmod)
```

Propensity scores much have what is known as "common support." In other words,
there must be overlap between treatment and control. Otherwise, matching would
be impossible. The boxplot serves as a visual check; ensuring that the two
ranges overlap substantially.

```{r}
boxplot(psmod)
```

# Pairmatching

The simplest and most straightforward matching scheme is pairmatching. Each
member of the treatment group is matched to a single member of the control
group, without overlap, such that the overall distance between propensity scores
in each matched pair is minimized.

```{r}
match1 <- pairmatch(psmod, data=nuclearplants)
match1
summary(match1)
```

The `data` argument in `pairmatch` is optional, but preferred, as dropping it
can yield to situations where the observation labels are confused. The `summary`
of the match shows first the size of each match, and here we see that there are
10 matches of a single treatment to a single control (pair-matches) and 12 cases
where there was an extra control and no available treatment members. This
illustrates a problem with pairmatching; if the size of the two groups are
dissimilar, a large number of observations could be discarded. Optimal matching,
discussed below, addresses this.

# Optimal Matching

If we relax the restriction that each match must contain exactly one treatment
and exactly one control member, we could utilize the entire sample. Define a
matched set as j:k, where j is the number of treatment members and k is the
number of control members, so that in pair matching, all sets would be
1:1. Optimal matching allows sets of size j:1 or 1:k, where j and k can vary per
set and are chosen optimally. (Sets where both j and k are greater than 1 won't
exist, because its always more optimal to split any such set up into multiple
j:1 or 1:k sets.) The `fullmatch` function performs this optimal matching.

```{r}
match2 <- fullmatch(psmod, data=nuclearplants)
match2
summary(match2)
```

As you can see, all observations are used here. There are only two pairmatches,
a single match involving multiple treatments to a single control (the `5+:1`
match) and several 1:k matches. We can see the exact size of each match via

```{r}
stratumStructure(match2)
```

## Restrictions on Optimal Matching

While the match we saw before is optimal in the sense that it produces to
minimum distance between matched elements in the propensity scores, it has two
perhaps undesirable traits. First, it contains a match which uses a lot of
treatment group members. In a lot of settings, the treatment group is small in
comparison to the control group, so we would want each treatment group member to
contribute fully (when in a j:1 match, each treatment member basically
contributes 1/j to the results). Secondly, the `1:8` and `1:9` sets are
dominating the results, such that our effective sample size of 8.58 is quite
low. We can perform the optimal matching under some restrictions to still gain
its benefits without falling into either trap.

The arguments `min.control`, `max.control` and `omit.fraction` control these
restrictions. The first two arguments restrict the size of matches, and
`omit.fraction` enforces dropping a percentage of the treatment or control
members. To illustrate their use, we give several examples.

1. From the `match2` above, we wish to ensure that each match set is no larger
than 5 (so that nothing larger than 4:1 or 1:4 exists).

```{r}
match3 <- fullmatch(psmod, data=nuclearplants, max.controls=4, min.controls=1/4)
summary(match3)
```

2. Let's ensure that each treatment is in its own unique set, so that we only
have 1:k sets, still with an upper bound of 1:4.

```{r}
match4 <- fullmatch(psmod, data=nuclearplants, max.controls=4, min.controls=1)
summary(match4)
```

3. Now, we want to have even smaller sets, so that only sets of 1:1 or 1:2 are
allowed.

```{r}
match5 <- fullmatch(psmod, data=nuclearplants, max.controls=2, min.controls=1)
summary(match5)
```

Note the warning and dropped control group members, given that we have 10
treatment and 22 control members, we couldn't use all the control members with
these restrictions.

4. The last match, `match5`, dropped 10 control group members. Is the match it
came up with after dropping those 10 (8 1:1's and 2 1:2 sets) optimal without
the `max.control` and `min.control` restrictions? Use `omit.fraction` to find
out.

```{r}
match6 <- fullmatch(psmod, data=nuclearplants, omit.fraction=10/22)
summary(match6)
```

We have a much different match structure. `match6` has an improved overall
distance btween matches (6.24 vs 8.3) but loses effective sample size (10.7 down
to 7.71).

5. It's possible to create restrictions which cannot be matched. For example, if
we wanted each treatment member to be matched to at least 3 control group
members, we'd need 30 control group members (but we only have 20). And unlike in
`match5` where some control group members were dropped to accommodate the
restrictions, `fullmatch` will not drop treatment members.

```{r}
match7 <- fullmatch(psmod, data=nuclearplants, min.controls=3)
summary(match7)
```
